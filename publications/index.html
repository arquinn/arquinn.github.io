<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>

  Andi  Quinn


  | Publications

</title>
<meta name="description" content="This is the professional website of Andi Quinn.  She is an Assistant Professor of Computer Science at UC Santa Cruz, a researcher of computer systems focusing on system reliability, a transwoman, and dog-mom.">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">


<!-- Styles -->

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22></text></svg>">

<link rel="stylesheet" href="/assets/css/main.css">
<link rel="canonical" href="/publications/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->






    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav sticky-bottom-footer">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="d-flex align-items-center">
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Andi</span> Quinn <span class="pronouns"> (she/they) </span>
      </a>
      <div class="navbar-icons d-flex align-items-center">
	<a href="mailto:%61%71%75%69%6E%6E%31@%75%63%73%63.%65%64%75"><i class="fas fa-envelope"></i></a>
	<a href="https://github.com/arquinn" target="_blank" title="GitHub" class="ml-2"><i class="fab fa-github"></i></a>
      </div>
    </div>

    <!-- Navbar Toggle -->
    <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item">
            <a class="nav-link" href="#about">
              About
            </a>
          </li>
	  <li class="nav-item">
            <a class="nav-link" href="#news">
              News
            </a>
          </li>
	  <li class="nav-item">
            <a class="nav-link" href="#team">
              Team
            </a>
          </li>
	  <li class="nav-item">
            <a class="nav-link" href="#teaching">
              Teaching
            </a>
          </li>
	  <li class="nav-item">
            <a class="nav-link" href="#publications">
              Publications
            </a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      <div class="post">
  <article>
    <div class="publications">



<h3> Conferences </h3>
<ol class="bibliography">

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">OOPSLA</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Scalable and Accurate Application-Level Crash-Consistency Testing via Representative Testing.</strong>
      
        
	   
	      Yile Gu,
	   
	
      
        
	   
	      Ian Neal,
	   
	
      
        
	   
	      Jiexiao Xu,
	   
	
      
        
	   
	      Shaun Christopher Lee,
	   
	
      
        
	   
	      Ayman Said,
	   
	
      
        
	   
	      Musa Haydar,
	   
	
      
        
	   
	      Jacob Van Geffen,
	   
	
      
        
	   
	      Rohan Kadekodi,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
 	   
	      Kasikci, Baris.
	   
	
      
      In Proceedings of the ACM on Programming Languages, Volumn 9, Issue OOPSLA.. April 2025
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Crash consistency is essential for applications that must persist data. Crash-consistency testing has been commonly applied to find crash-consistency bugs in applications. The crash-state space grows exponentially as the number of operations in the program increases, necessitating techniques for pruning the search space. However, state-of-the-art crash-state space pruning is far from ideal. Some techniques look for known buggy patterns or bound the exploration for efficiency, but they sacrifice coverage and may miss bugs lodged deep within applications. Other techniques eliminate redundancy in the search space by skipping identical crash states, but they still fail to scale to larger applications.
In this work, we propose representative testing: a new crash-state space reduction strategy that achieves high scalability and high coverage. Our key observation is that the consistency of crash states is often correlated, even if those crash states are not identical. We build Pathfinder, a crash-consistency testing tool that implements an update behaviors-based heuristic to approximate a small set of representative crash states.
We evaluate Pathfinder on POSIX-based and MMIO-based applications, where it finds 18 (7 new) bugs across 8 production-ready systems. Pathfinder scales more effectively to large applications than prior works and finds 4x more bugs in POSIX-based applications and 8x more bugs in MMIO-based applications compared to state-of-the-art systems.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">OSDI</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Extending Applications Safely and Efficiently.</strong>
      
        
	   
	      Yusheng Zheng,
	   
	
      
        
	   
	      Tong Yu,
	   
	
      
        
	   
	      Yiwei Yang,
	   
	
      
        
	   
	      Yanpeng Hu,
	   
	
      
        
	   
	      Xiaozheng Lai,
	   
	
      
        
	   
	      Dan Williams,
	   
	
      
        
 	   
	      <em>Andi Quinn</em>.
	   
	
      
      In Proceedings of the 19th USENIX Symposium on Operating Systems Design and Implementation. July 2025
      </p>
      </div>
      <div class="links">
        
	
	<!-- Hidden abstract block -->
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">ISSTA</abbr>
      
      
           <p class="award"> Distinguished Artifact </p>
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>GPUHarbor: Testing GPU Memory Consistency At Large (Experience  Paper).</strong>
      
        
	   
	      Reese Levine,
	   
	
      
        
	   
	      Mingun Cho,
	   
	
      
        
	   
	      Devon McKee,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
 	   
	      Tyler Sorensen.
	   
	
      
      In Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis and Implementation. July 2023
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Memory consistency specifications (MCSs) are a difficult, yet critical, part of a concurrent programming framework. Existing MCS testing tools are not immediately accessible, and thus, they have only been applied to a limited number of platforms. However, in the post-Dennard scaling landscape, there has been an explosion of new architectures and frameworks, especially for GPUs. Studying the shared memory behaviors of different devices (across vendors and architecture generations) is important to ensure conformance and to understand the extent that devices show different behaviors.  In this paper, we present GPUHarbor, a widescale GPU MCS testing tool. GPUHarbor has two interfaces: a web interface and an Android app. Using GPUHarbor, we deployed a testing campaign that checks conformance and characterizes weak behaviors. We advertised GPUHarbor on forums and social media, allowing us to collect testing data from 106 devices, spanning seven vendors. In terms of devices tested, this constitutes the largest study on weak memory behaviors by at least 10×, and our conformance tests identified two new bugs on embedded Arm and NVIDIA devices. Analyzing our characterization data yields many insights, including quantifying and comparing weak behavior occurrence rates (e.g., AMD GPUs show 25.3× more weak behaviors on average than Intel). We conclude with a discussion of the impact our results have on software development for these performance-critical devices.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">ASPLOS</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Vidi: Record Replay for Reconfigurable Hardware.</strong>
      
        
	   
	      Gefei Zuo,
	   
	
      
        
	   
	      Jiacheng Ma,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
 	   
	      Baris Kasikci.
	   
	
      
      In Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 3. March 2023
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p></p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">ASPLOS</abbr>
      
      
           <p class="award"> Distinguished Paper </p>
      
           <p class="award"> Distinguished Artifact </p>
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>MC Mutants: Evaluating and Improving Testing for Memory Consistency Specifications.</strong>
      
        
	   
	      Reese Levine,
	   
	
      
        
	   
	      Tianhao Guo,
	   
	
      
        
	   
	      Mingun Cho,
	   
	
      
        
	   
	      Allen Baker,
	   
	
      
        
	   
	      Raph Levien,
	   
	
      
        
	   
	      David Neto,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
 	   
	      Tyler Sorensen.
	   
	
      
      In Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 2. March 2023
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Shared memory platforms provide a memory consistency specification (MCS) so that developers can reason about the behaviors of their parallel programs. Unfortunately, ensuring that a platform conforms to its MCS is difficult, as is exemplified by numerous bugs in well-used platforms. While existing MCS testing approaches find bugs, their efficacy depends on the testing environment (e.g. if synthetic memory pressure is applied). MCS testing environments are difficult to evaluate since legitimate MCS violations are too rare to use as an efficacy metric. As a result, prior approaches have missed critical MCS bugs. This work proposes a mutation testing approach for evaluating MCS testing environments: MC Mutants. This approach mutates MCS tests such that the mutants simulate bugs that might occur. A testing environment can then be evaluated using a mutation score. We utilize MC Mutants in two novel contributions: (1) a parallel testing environment, and (2) An MCS testing confidence strategy that is parameterized over a time budget and confidence threshold. We implement our contributions in WebGPU, a new web-based GPU programming specification, and evaluate our techniques across four GPUs. We improve testing speed by three orders of magnitude over prior work, empowering us to create a conformance test suite that reproduces many mutated tests with high confidence and requires only 64 seconds per test. We identified two bugs in WebGPU implementations, one of which led to a specification change. Moreover, the official WebGPU conformance test suite has adopted our approach due to its efficiency, effectiveness, and broad applicability.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">OSDI</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Debugging the OmniTable Way.</strong>
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
	   
	      Michael Cafarella,
	   
	
      
        
	   
	      Jason Flinn,
	   
	
      
        
 	   
	      Baris Kasikci.
	   
	
      
      In Proceedings of the 16th USENIX Symposium on Operating Systems Design and Implementation. July 2022
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Debugging is time-consuming, accounting for roughly 50% of a developer's time. To identify the cause of a failure, a developer usually tracks the state of their program as it executes on a failing input.  Unfortunately, most debugging tools make it difficult for a developer to specify the program state that they wish to observe and computationally expensive to observe execution state.  Moreover, existing work to improve our debugging tools often restrict the state that a developer can track by either exposing incomplete execution state or requiring manual instrumentation.  In this paper, we propose an OmniTable, an abstraction that captures all execution state as a large queryable data table.  We build a query model around an OmniTable that supports SQL to simplify debugging without restricting the state that a developer can observe: we find that OmniTable debugging queries are more succinct than equivalent logic specified using existing tools.  An OmniTable decouples debugging logic from the original execution, which SteamDrill, our prototype, uses to reduce the performance overhead of debugging. The system employs *lazy materialization*: it uses deterministic record/replay to store the execution associated with each OmniTable and resolves queries by inspecting replay executions.  It employs a novel multi-replay strategy that partitions query resolution across multiple replays and a parallel resolution strategy that simultaneously observes state at multiple points-in-time.  We find that SteamDrill queries are an order-of-magnitude faster than existing debugging tools.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">ASPLOS</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Debugging in the Brave New World of Reconfigurable Hardware.</strong>
      
        
	   
	      Jiacheng Ma,
	   
	
      
        
	   
	      Gefei Zuo,
	   
	
      
        
	   
	      Kevin Loughlin,
	   
	
      
        
	   
	      Haoyang Zhang,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
 	   
	      Baris Kasikci.
	   
	
      
      In Proceedings of the 27th ACM International Conference on Architectural Support for Programming Languages and Operating Systems. Feb 2022
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Software and hardware development cycles have traditionally been quite distinct. Software allows post-deployment patches, which leads to a rapid development cycle. In contrast, hardware bugs that are found after fabrication are extremely costly to fix (and sometimes even unfixable), so the traditional hardware development cycle involves massive investment in extensive simulation and formal verification. Reconfigurable hardware, such as a Field Programmable Gate Array (FPGA), promises to propel hardware development towards an agile software-like development approach, since it enables a hardware developer to patch bugs that are detected during on-chip testing or in production. Unfortunately, FPGA programmers lack bug localization tools amenable to this rapid development cycle, since past tools mainly find bugs via simulation and verification. To develop hardware bug localization tools for a rapid development cycle, a thorough understanding of the symptoms, root causes, and fixes of hardware bugs is needed.  In this paper, we first study bugs in existing FPGA designs and produce a testbed of reliably-reproducible bugs. We classify the bugs according to their intrinsic properties, symptoms, and root causes. We demonstrate that many hardware bugs are comparable to software bug counterparts, and would benefit from similar techniques for bug diagnosis and repair. Based upon our findings, we build a novel collection of hybrid static/dynamic program analysis and monitoring tools for debugging FPGA designs, showing that our tools enable a software-like development cycle by effectively reducing developers' manual efforts for bug localization.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">PLDI</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Execution Reconstruction: Harnessing Failure Reoccurrences for Failure Reproduction.</strong>
      
        
	   
	      Gefei Zuo,
	   
	
      
        
	   
	      Jiacheng Ma,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
	   
	      Pramod Bhatotia,
	   
	
      
        
	   
	      Pedro Fonseca,
	   
	
      
        
 	   
	      Baris Kasikci,.
	   
	
      
      In Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation. July 2021
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Reproducing production failures is crucial for software reliability. Alas, existing bug reproduction approaches are not suitable for production systems because they are not simultaneously efficient, effective, and accurate. In this work, we survey prior techniques and show that existing approaches over-prioritize a subset of these properties, and sacrifice the remaining ones. As a result, existing tools do not enable the plethora of proposed failure reproduction use-cases (e.g., debugging, security forensics, fuzzing) for production failures.  We propose Execution Reconstruction (ER), a technique that strikes a better balance between efficiency, effectiveness and accuracy for reproducing production failures. ER uses hardware-assisted control and data tracing to shepherd symbolic execution and reproduce failures. ER’s key novelty lies in identifying data values that are both inexpensive to monitor and useful for eliding the scalability limitations of symbolic execution. ER harnesses failure reoccurrences by iteratively performing tracing and symbolic execution, which reduces runtime overhead. Whereas prior production-grade techniques can only reproduce short executions, ER can reproduce any reoccuring failure. Thus, unlike existing tools, ER reproduces fully replayable executions that can power a variety of debugging and reliabilty use cases. ER incurs on average 0.3% (up to 1.1%) runtime monitoring overhead for a broad range of real-world systems, making it practical for real-world deployment.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">ASPLOS</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Hippocrates: Healing Persistent Memory Bugs without Doing Any Harm.</strong>
      
        
	   
	      Ian Neal,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
 	   
	      Baris Kasikci.
	   
	
      
      In Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems. Apr 2021
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Persistent memory (PM) technologies aim to revolutionize storage systems, providing persistent storage at near-DRAM speeds. Alas, programming PM systems is error-prone, as the misuse or omission of the durability mechanisms (i.e., cache flushes and memory fences) can lead to durability bugs (i.e., unflushed updates in CPU caches that violate crash consistency). PM-specific testing and debugging tools can help developers find these bugs, however even with such tools, fixing durability bugs can be challenging.  To determine the reason behind this difficulty, we first study durability bugs and find that although the solution to a durability bug seems simple, the actual reasoning behind the fix can be complicated and time-consuming. Overall, the severity of these bugs coupled with the difficultly of developing fixes for them motivates us to consider automated approaches to fixing durability bugs.  We introduce Hippocrates, a system that automatically fixes durability bugs in PM systems. Hippocrates automatically performs the complex reasoning behind durability bug fixes, relieving developers of time-consuming bug fixes. Hippocrates’s fixes are guaranteed to be safe, as they are guaranteed to not introduce new bugs (“do no harm”). We use Hippocrates to automatically fix 23 durability bugs in realworld and research systems. We show that Hippocrates produces fixes that are functionally equivalent to developer fixes. We then show that solely using Hippocrates’s fixes, we can create a PM port of Redis which has performance rivaling and exceeding the performance of a manually-developed PM-port of Redis.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">OSDI</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Agamotto: How Persistent is your Persistent Memory Application?.</strong>
      
        
	   
	      Ian Neal,
	   
	
      
        
	   
	      Ben Reeves,
	   
	
      
        
	   
	      Ben Stoler,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
	   
	      Youngjin Kwon,
	   
	
      
        
	   
	      Simon Peter,
	   
	
      
        
 	   
	      Baris Kasikci.
	   
	
      
      In Proceedings of the 14th USENIX Symposium on Operating Systems Design and Implementation. Nov 2020
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Persistent Memory (PM) can be used by applications to directly and quickly persist any data structure, without the overhead of a file system. However, writing PM applications that are simultaneously correct and efficient is challenging. As a result, PM applications contain correctness and performance bugs. Prior work on testing PM systems has low bug coverage as it relies primarily on extensive test cases and developer annotations.  In this paper we aim to build a system for more thoroughly testing PM applications. We inform our design using a detailed study of 63 bugs from popular PM projects. We identify two application-independent patterns of PM misuse which account for the majority of bugs in our study and can be detected automatically. The remaining application-specific bugs can be detected using compact custom oracles provided by developers. We then present AGAMOTTO, a generic and extensible system for discovering misuse of persistent memory in PM applications. Unlike existing tools that rely on extensive test cases or annotations, AGAMOTTO symbolically executes PM systems to discover bugs. AGAMOTTO introduces a new symbolic memory model that is able to represent whether or not PM state has been made persistent. AGAMOTTO uses a state space exploration algorithm, which drives symbolic execution towards program locations that are susceptible to persistency bugs. AGAMOTTO has so far identified 84 new bugs in 5 different PM applications and frameworks while incurring no false positives.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">OSDI</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Sledgehammer: Cluster-Fueled Debugging.</strong>
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
	   
	      Jason Flinn,
	   
	
      
        
 	   
	      Michael Cafarella.
	   
	
      
      In Proceedings of the 13th USENIX Symposium on Operating Systems Design and Implementation. Oct 2018
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Current debugging tools force developers to choose between power and interactivity. Interactive debuggers such as gdb let them quickly inspect application state and monitor execution, which is perfect for simple bugs. However, they are not powerful enough for complex bugs such as wild stores and synchronization errors where developers do not know which values to inspect or when to monitor the execution. So, developers add logging, insert timing measurements, and create functions that verify invariants. Then, they re-run applications with this instrumentation. These powerful tools are, unfortunately, not interactive; they can take minutes or hours to answer one question about a complex execution, and debugging involves asking and answering many such questions.  In this paper, we propose cluster-fueled debugging, which provides interactivity for powerful debugging tools by parallelizing their work across many cores in a cluster. At sufficient scale, developers can get answers to even detailed queries in a few seconds. Sledgehammer is a cluster-fueled debugger: it improves performance by timeslicing program execution, debug instrumentation, and analysis of results, and then executing each chunk of work on a separate core. Sledgehammer enables powerful, interactive debugging tools that are infeasible today. Parallel retro-logging allows developers to change their logging instrumentation and then quickly see what the new logging would have produced on a previous execution. Continuous function evaluation logically evaluates a function such as a data-structure integrity check at every point in a program’s execution. Retro-timing allows fast performance analysis of a previous execution. With 1024 cores, Sledgehammer executes these tools hundreds of times faster than single-core execution while returning identical results.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">OSDI</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>JetStream: Cluster-Scale Parallelization of Information Flow Queries.</strong>
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
	   
	      David Devecsery,
	   
	
      
        
	   
	      Peter M. Chen,
	   
	
      
        
 	   
	      Jason Flinn.
	   
	
      
      In Proceedings of the 12th USENIX Symposium on Operating Systems Design and Implementation. Nov 2016
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Dynamic information flow tracking (DIFT) is an importanttool in many domains, such as security, debugging, forensics, provenance, configuration troubleshooting, and privacy tracking. However, the usability of DIFT is currently limited by its high overhead; complex information flow queries can take up to two orders of magnitude longer to execute than the original execution of the program. This precludes interactive uses in which users iteratively refine queries to narrow down bugs, leaks of private data, or performance anomalies. JetStream applies cluster computing to parallelize and accelerate information flow queries over past executions. It uses deterministic record and replay to time slice executions into distinct contiguous chunks of execution called epochs, and it tracks information flow for each epoch on a separate core in the cluster. It structures the aggregation of information flow data from each epoch as a streaming computation. Epochs are arranged in a sequential chain from the beginning to the end of program execution; relationships to program inputs (sources) are streamed forward along the chain, and relationships to program outputs (sinks) are streamed backward. Jet- Stream is the first system to parallelize DIFT across a cluster. Our results show that JetStream queries scale to at least 128 cores over a wide range of applications. JetStream accelerates DIFT queries to run 12–48 times faster than sequential queries; in most cases, queries run faster than the original execution of the program.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

</ol>



<h3> Workshops </h3>
<ol class="bibliography">

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">CHEOPS</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>Lethe: Secure Deletion by Addition.</strong>
      
        
	   
	      Eugene Chou,
	   
	
      
        
	   
	      Leo Conrad-Shah,
	   
	
      
        
	   
	      Austen Barker,
	   
	
      
        
	   
	      Ethan Miller,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
 	   
	      Darell D. E. Long.
	   
	
      
      In Proceedings of the 3rd Workshop on Challenges and Opportunities of Efficient and Performant Storage Systems. May 2023
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p></p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">YArch</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>CXLMemSim: A pure software simulated CXL.mem for performance characterization.</strong>
      
        
	   
	      Yiwei Yang,
	   
	
      
        
	   
	      Pooneh Safayenikoo,
	   
	
      
        
	   
	      Jiacheng Ma,
	   
	
      
        
	   
	      Tanvir Ahmed Khan,
	   
	
      
        
 	   
	      <em>Andi Quinn</em>.
	   
	
      
      In Proceedings of the 5th Young Architects Workshop. March 2023
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>The emerging CXL.mem standard provides a new type of byte-addressable remote memory with a variety of memory types and hierarchies. With CXL.mem, multiple layers of memory -- e.g., local DRAM and CXL-attached remote memory at different locations -- are exposed to operating systems and user applications, bringing new challenges and research opportunities. Unfortunately, since CXL.mem devices are not commercially available, it is difficult for researchers to conduct systems research that uses CXL.mem. In this paper, we present our ongoing work, CXLMemSim, a fast and lightweight CXL.mem simulator for performance characterization. CXLMemSim uses a performance model driven using performance monitoring events, which are supported by most commodity processors. Specifically, CXLMemSim attaches to an existing, unmodified program, and divides the execution of the program into multiple epochs; once an epoch finishes, CXLMemSim collects performance monitoring events and calculates the simulated execution time of the epoch based on these events. Through this method, CXLMemSim avoids the performance overhead of a full-system simulator (e.g., Gem5) and allows the memory hierarchy and latency to be easily adjusted, enabling research such as memory scheduling for complex applications. Our preliminary evaluation shows that CXLMemSim slows down the execution of the attached program by 4.41x on average for real-world applications. </p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">HotEdge</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>The Case for Determinism on the Edge.</strong>
      
        
	   
	      Matthew Furlong,
	   
	
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
 	   
	      Jason Flinn.
	   
	
      
      In Proceedings of the 2nd USENIX Workshop on Hot Topics in Edge Computing. July 2019
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>Emerging edge applications, such as augmented and virtual reality, real-time video analytics and thin-client gaming, are latency-sensitive, resource-intensive, and stateful. Transitioning these applications from cloud deployments to the edge is non-trivial since edge deployments will exhibit variable resource availability, significant user mobility, and high potential for faults and application preemption, requiring considerable developer effort per application to maintain stable quality of experience for the user.
In this paper, we propose deterministic containers, a new abstraction that simplifies the development of complex applications on the edge. Deterministic containers enforce the property that all activity within a container behave deterministically. Determinism provides replication, which in turn provides key benefits for edge computing including resilience to performance jitter, enhanced fault-tolerance, seamless migration, and data provenance.
We are currently building a prototype, Shadow, that aims to provide deterministic containers with minimal performance overhead while requiring few application modifications. For all sources of non-determinism, Shadow either converts the behavior to be deterministic or restricts the allowable application behavior. Preliminary results indicate that using Shadow to reduce performance jitter at the edge for a vehicle caravan application involving video analytics reduces median application response time by up to 25%.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

  <li>
  <div class="row">
    <div class="abbr">
      
        <abbr class="badge">HotOS</abbr>
      
      
    </div>

    <div class="main">
      <div class="citation">
      <p>
      <strong>You Can't Debug What You Can't See: Expanding Observability with the OmniTable.</strong>
      
        
	   
	      <em>Andi Quinn</em>,
	   
	
      
        
	   
	      Jason Flinn,
	   
	
      
        
 	   
	      Michael Cafarella.
	   
	
      
      In Proceedings of the Workshop on Hot Topics in Operating Systems. may 2019
      </p>
      </div>
      <div class="links">
        
          <a class="abstract btn btn-sm z-depth-0" role="button">Abs</a>
        
	
	<!-- Hidden abstract block -->
	
	  <div class="abstract hidden">
	     <p>The effectiveness of a debugging tool is fundamentally limited by what program state it can observe. Yet, for performance reasons, all current debugging tools restrict the program state that can be observed in some way. For example, tools like heap analysis restrict what can be observed (i.e., only global variables) and tools like core dump analysis restrict when observations may be made (i.e., only on program termination).  Other tools effectively limit the scope of observation by requiring developers to specify what and when observations will be made before execution (e.g., logging) or during an execution (e.g., gdb).We propose a new abstraction for debugging, called an OmniTable, that logically exposes unrestricted access to all program state at all points in an execution to developers. The OmniTable represents a program execution as a database-style table. Developers inspect the OmniTable using a familiar declarative query language: SQL. SQL simplifies the observation and analysis of large, complex execution state. Iterative queries are inherently consistent since they operate over the same logical table.Clearly, materializing the OmniTable for even a simple program is infeasible due to storage and processing overheads. Thus, our prototype, SteamDrill, selectively materializes only the regions of the OmniTable required to answer each query by using deterministic record and replay to reproduce the execution and dynamic instrumentation to extract needed state. By expressing debugging queries with relational logic, SteamDrill leverages proven optimizations such as query optimization and caching.  In addition, decomposition into relational logic allows a query to be executed via repeated replays, each replay extracting information needed by the next, which can often be more efficient than extracting all information during a single execution.</p>
	  </div>
	
      </div> <!-- end of linkds -->
    </div> <!-- end of col-sm-8-->
  </div> <!--end of row-->
  </li>

</ol>
</div>

  </article>

</div>

    </div>

    <!-- Footer -->

    <footer class="sticky-bottom mt-5">
  <div class="container">
    &copy; Copyright 2025 Andi  Quinn.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a>; hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.
  </div>
</footer>


  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Medium Zoom JS -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/assets/js/zoom.js"></script>


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
